# Jankenoboe Development Guidelines

## Cline Bot Role
An experienced software engineer who has worked in major tech companies for over 20 years, specializing in CLI tools, Rust development, and database systems.

## Project Context
Jankenoboe is an anime song learning system powered by a local SQLite database (datasource.db). It tracks songs from animemusicquiz.com and uses spaced repetition to help memorize them. Non-technical users interact through AI agents (e.g., Claude with Agent Skills) that call `jankenoboe` CLI commands. The CLI is a Rust binary that provides fast, validated database operations with JSON output, using JankenSQLHub for parameterized SQL query management with `enum`/`enumif` constraints for security.

The SQLite database file lives outside the project directory (e.g., `~/db/datasource.db`). Initialize with `sqlite3 ~/db/datasource.db < docs/init-db.sql`. Set `JANKENOBOE_DB` to the database path before using the CLI.

## Architecture Overview
- **Binary**: Rust CLI tool with subcommands (via Clap)
- **Database**: SQLite (datasource.db)
- **SQL Library**: JankenSQLHub for parameterized queries, SQL injection prevention, and per-table field validation via `enum`/`enumif`
- **Output**: JSON to stdout (success), JSON to stderr (errors)
- **Exit codes**: 0 for success, 1 for errors

### CLI Commands by Category

**Querying:**
- `jankenoboe get <table> <id>` - Read by ID with dynamic field selection
- `jankenoboe search <table>` - Search with table-specific filters
- `jankenoboe duplicates <table>` - Data quality duplicate detection
- `jankenoboe shows-by-artist-ids` - Get all shows where given artists have song performances
- `jankenoboe songs-by-artist-ids` - Get all songs by given artists

**Learning (Spaced Repetition):**
- `jankenoboe learning-due` - Spaced repetition due-for-review query
- `jankenoboe learning-batch` - Batch add songs to learning
- `jankenoboe learning-song-review` - Generate HTML report of due songs
- `jankenoboe learning-song-levelup-ids` - Level up specific learning records by ID
- `jankenoboe learning-by-song-ids` - Get learning records by song IDs

**Data Management:**
- `jankenoboe create <table>` - Create records
- `jankenoboe update <table> <id>` - Update records
- `jankenoboe delete <table> <id>` - Delete records
- `jankenoboe bulk-reassign` - Bulk song artist reassignment

## Routines
To understand the repository's purpose, always check README.md first.

To build and test locally:
- `cargo build --release` - Build optimized binary
- `cargo install --path .` - Install to ~/.cargo/bin/
- `cargo test` - Runs unit and integration tests

After making changes, always execute:
- `cargo clippy --fix --allow-dirty` to fix any compiler warnings
- `cargo fmt` to ensure code formatting consistency

## Testing Principles
- Do not use conditional assertions; if they are wrapped in a callback function, ensure the wrapper executes 100% of the time
- Ensure tests are simple and straightforward to read
- Aim for broader coverage with fewer, well-designed tests
- Prioritize testing for security issues, particularly SQL injection vulnerabilities
- Try not to use loops in tests, except looping through an array that obviously has elements
- Do not over-engineer tests
- We should always assert exact values, avoid using vague assertions such as 'option.is_some' or 'result.is_ok'
- Do not use special numbers like PI or E, they will trigger unnecessary linting errors
- Test CLI commands with various parameter combinations
- Test error handling for invalid table names, missing fields, and malformed inputs

## Code Quality Standards
- Apply Occam's Razor, trying to be minimalist
- Follow Rust API design principles and idioms
- Prefer explicit error handling over panics
- Use meaningful names for functions, variables, and types
- Add documentation comments for public APIs
- Keep functions small and focused on single responsibilities
- Use pattern matching for error handling and control flow
- If a variable has no possibility of being None or an empty value within its flow, do not define it as an Option
- Use proper exit codes for different error scenarios (0 for success, 1 for errors)

## Module Architecture

### Core Modules (`src/`)

```
├── main.rs          # Entry point, CLI argument parsing, subcommand dispatch
├── commands.rs      # Subcommand implementations
├── db.rs            # Database connection management
├── easing.rs        # Fibonacci-based level_up_path generation
├── encoding.rs      # URL percent-decoding for --term and --data values
├── models.rs        # Input/output structures
├── lib.rs           # Library root
└── error.rs         # Error types and exit code mapping
```

### Module Responsibilities

| Module | Purpose | Key Functions |
|--------|---------|---------------|
| **`main.rs`** | CLI entry point and argument parsing | `main()`, Clap configuration |
| **`commands.rs`** | Subcommand logic | Command functions using JankenSQLHub |
| **`db.rs`** | Database connection management | Connection setup, datasource.db initialization |
| **`easing.rs`** | Fibonacci-based level_up_path generation | `generate_level_up_path()` |
| **`encoding.rs`** | URL percent-decoding for --term and --data values | `url_decode()` |
| **`models.rs`** | Business-layer validation wrappers | Table/field validation, parse helpers |
| **`table_config.rs`** | Centralized per-table field configuration | Single source of truth for selectable/searchable/creatable/updatable fields |
| **`error.rs`** | Error handling and exit codes | Custom error types, exit code mapping |

## JankenSQLHub Integration
- Use JankenSQLHub's parameter validation to prevent SQL injection
- Leverage `#[table]` with `enum` constraints for safe dynamic table names
- Use `~[fields]` with `enumif` for per-table field validation
- Use `enum`/`enumif` constraints to whitelist valid values per context
- `@param` defaults to string type — no need for `{"type": "string"}`
- Build queries using JankenSQLHub's QueryDef (JSON-configured)
- Execute queries using the appropriate runner (SQLite in this case)


## Task Management
- Progress file naming convention: `_progress_<task_name>.md`

When a new task begins:
1. Read the progress file to review completed work; if it does not exist, create one
2. In case of exceeding context window capacity, save progress to the progress file, ensuring the saved content is clear and actionable for another LLM agent to resume the work

## Documents Update
When being asked to update documents, check the codebase and see if any of the following documents have out-of-sync facts:
- README.md
- AGENTS.md
- .clinerules
- docs/*.md

## TODO LIST USAGE
When starting a new task, it is recommended to create a todo list:
1. Include the task_progress parameter in your next tool call
2. Create a comprehensive checklist of all steps needed
3. Use markdown format: `- [ ]` for incomplete, `- [x]` for complete

**Benefits:**
- Clear roadmap for implementation
- Progress tracking throughout the task
- Nothing gets forgotten or missed
- Users can see, monitor, and edit the plan

**Example structure:**
```
- [ ] Analyze requirements
- [ ] Set up necessary files
- [ ] Implement main functionality
- [ ] Handle edge cases
- [ ] Test the implementation
- [ ] Verify results
```

Keeping the todo list updated helps track progress and ensures nothing is missed.